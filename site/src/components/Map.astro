---
// Leaflet Map Component
const baseUrl = import.meta.env.BASE_URL;
---

<div class="bg-white rounded-2xl overflow-hidden card-hover">
  <div class="p-4 flex items-center justify-between">
    <h2 class="text-xs font-medium text-gray-400 uppercase tracking-wide">Locations</h2>
    <div class="flex items-center gap-4 text-xs text-gray-400">
      <span class="flex items-center gap-1.5"><span class="w-2 h-2 rounded-full bg-teal-500"></span> Completed</span>
      <span class="flex items-center gap-1.5"><span class="w-2 h-2 rounded-full bg-amber-400"></span> In Progress</span>
      <span class="flex items-center gap-1.5"><span class="w-2 h-2 rounded-full bg-violet-400"></span> Planned</span>
    </div>
  </div>
  <div id="map" class="h-80 w-full"></div>
</div>

<script define:vars={{ baseUrl }}>
  // Wait for Leaflet to be available
  async function initMap() {
    if (typeof L === 'undefined') {
      // Leaflet not loaded yet, wait and retry
      setTimeout(initMap, 100);
      return;
    }

    // Check if map already initialized
    const mapContainer = document.getElementById('map');
    if (!mapContainer || mapContainer._leaflet_id) return;

    // Initialize map centered on Nordic region
    const map = L.map('map').setView([62, 10], 4);

    // Add tile layer (CartoDB Positron - minimal, light style)
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 19,
    }).addTo(map);

    // Status-based colors (muted, Apple-inspired)
    const statusColors = {
      completed: '#14b8a6',      // teal
      under_construction: '#fbbf24', // amber
      planned: '#a78bfa',        // violet
      operational: '#14b8a6'     // teal (same as completed)
    };

    // Create marker icon based on status
    function createIcon(status) {
      const color = statusColors[status] || '#6b7280';
      return L.divIcon({
        className: 'custom-marker',
        html: `<div style="background-color: ${color}; width: 14px; height: 14px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
        iconSize: [18, 18],
        iconAnchor: [9, 9],
      });
    }

    // Load project data
    try {
      const response = await fetch(`${baseUrl}/data/norway.json`);
      const data = await response.json();

      // Store markers for filtering
      const markers = [];

      // Add markers for each project
      data.projects.forEach((project) => {
        if (project.location?.coordinates) {
          const { lat, lng } = project.location.coordinates;

          const marker = L.marker([lat, lng], { icon: createIcon(project.status) })
            .bindPopup(`
              <div style="min-width: 200px;">
                <strong style="font-size: 14px;">${project.name}</strong>
                <p style="color: #666; margin: 4px 0;">${project.location.city}</p>
                <p style="font-size: 12px; margin: 4px 0;">${project.building_type.replace('_', ' ')}</p>
                ${project.metrics?.circularity_rate?.value
                  ? `<p style="color: #228b66; font-weight: bold;">${project.metrics.circularity_rate.value}% circularity</p>`
                  : ''}
                <a href="${baseUrl}/project/${project.id}" style="color: #2d7fc0; font-size: 12px;">View details â†’</a>
              </div>
            `)
            .addTo(map);

          // Store project data on marker for filtering
          marker.projectData = project;
          markers.push(marker);
        }
      });

      // Listen for filter changes to update map
      window.addEventListener('filterChange', (e) => {
        const filters = e.detail;

        markers.forEach((marker) => {
          const project = marker.projectData;
          let visible = true;

          // Check country filter
          if (filters.country.length > 0 && !filters.country.includes(project.country)) {
            visible = false;
          }

          // Check status filter
          if (filters.status.length > 0 && !filters.status.includes(project.status)) {
            visible = false;
          }

          // Check building type filter
          if (filters.building_type.length > 0 && !filters.building_type.includes(project.building_type)) {
            visible = false;
          }

          // Check strategy filter
          if (filters.strategy.length > 0) {
            const hasStrategy = filters.strategy.some((s) =>
              project.primary_strategies?.includes(s)
            );
            if (!hasStrategy) visible = false;
          }

          // Check circularity filter
          if (filters.minCircularity > 0) {
            const rate = project.metrics?.circularity_rate?.value || 0;
            if (rate < filters.minCircularity) visible = false;
          }

          // Toggle marker visibility
          if (visible) {
            marker.addTo(map);
          } else {
            marker.remove();
          }
        });
      });

      // Fit bounds to markers
      if (markers.length > 0) {
        const group = L.featureGroup(markers);
        map.fitBounds(group.getBounds().pad(0.1));
      }
    } catch (error) {
      console.error('Error loading project data:', error);
    }
  }

  // Start initialization
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMap);
  } else {
    initMap();
  }
</script>

<style>
  .custom-marker {
    background: transparent;
    border: none;
  }
</style>
